---
title: Dubbo Cluster如何获取最优的服务提供者？
date: 2020-05-19 22:07:51
categories: dubbo
tags: [Cluster]
---

> Cluster的核心功能之一就是寻找出合适的服务提供者，供消费者远程调用。 
> 如何寻找：
>
> 1. 获取消费者能够远程调用的所有服务提供者列表。
>
> 2. 选择合适的Invoker。
>
> 3. 如果只有一个Invoker则直接返回，有多个Invoker，则通过loadbalance组件选择出合适的Invoker。 
>
>     <!--more-->

#### 概念

Invocation：会话域，它持有调用过程中的变量，比如方法名，参数等。 
Invoker:实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。

#### 概述

集群 Cluster 用途是将多个服务提供者合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者。以Failover Cluster为基础了解Cluster执行

 Cluster：

```java
@SPI(FailoverCluster.NAME)
public interface Cluster {

    /**
     * Merge the directory invokers to a virtual invoker.
     *
     * @param <T>
     * @param directory
     * @return cluster invoker  
     * @throws RpcException
     */
    @Adaptive
    <T> Invoker<T> join(Directory<T> directory) throws RpcException;
}
```

 

```java
public class FailoverCluster implements Cluster {

    public final static String NAME = "failover";

    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        // 创建并返回FailoverClusterInvoker
        return new FailoverClusterInvoker<T>(directory);
    }
}
```

#### Cluster获取Invoker流程

AbstractClusterInvoker:

 

```java
@Override
public Result invoke(final Invocation invocation) throws RpcException {
    checkWhetherDestroyed();
    // binding attachments into invocation.
    Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();
    if (contextAttachments != null && contextAttachments.size() != 0) {
        ((RpcInvocation) invocation).addAttachments(contextAttachments);
    }
    // 列举invoker
    List<Invoker<T>> invokers = list(invocation);
    // 加载LoadBalance 
    LoadBalance loadbalance = initLoadBalance(invokers, invocation);
    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
    return doInvoke(invocation, invokers, loadbalance);
}
```

FailoverClusterInvoker

 

```java
@Override
@SuppressWarnings({"unchecked", "rawtypes"})
public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
    List<Invoker<T>> copyInvokers = invokers;
    // invokers判空检查
    checkInvokers(copyInvokers, invocation);
          // 获取访问的方法
    String methodName = RpcUtils.getMethodName(invocation);    
    // 重试次数
    int len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + 1;
    if (len <= 0) {
        len = 1;
    }
    // retry loop.
    RpcException le = null; // last exception.
    List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size()); // invoked invokers.
    Set<String> providers = new HashSet<String>(len);
    for (int i = 0; i < len; i++) {
        if (i > 0) {
            // 在进行重试前重新列举Invoker，这样做的好数是如果某个服务挂了，通过调用list可得到最新可用的Invoker列表
            checkWhetherDestroyed();
            copyInvokers = list(invocation);
            // check again
            checkInvokers(copyInvokers, invocation);
        }
         // 通过负载均衡选择invoker
        Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);
        // 添加invoker到invoked 列表中
        invoked.add(invoker);
        // 设置invoked到RPC上下文中
        RpcContext.getContext().setInvokers((List) invoked);
        try {
            // 调用目标Invoker的invoke方法
            Result result = invoker.invoke(invocation);
            if (le != null && logger.isWarnEnabled()) {
                logger.warn("Although retry the method " + methodName
                        + " in the service " + getInterface().getName()
                        + " was successful by the provider " + invoker.getUrl().getAddress()
                        + ", but there have been failed providers " + providers
                        + " (" + providers.size() + "/" + copyInvokers.size()
                        + ") from the registry " + directory.getUrl().getAddress()
                        + " on the consumer " + NetUtils.getLocalHost()
                        + " using the dubbo version " + Version.getVersion() + ". Last error is: "
                        + le.getMessage(), le);
            }
            return result;
        } catch (RpcException e) {
            if (e.isBiz()) { // biz exception.
                throw e;
            }
            le = e;
        } catch (Throwable e) {
            le = new RpcException(e.getMessage(), e);
        } finally {
            providers.add(invoker.getUrl().getAddress());
        }
    }
    throw new RpcException(le.getCode(), "Failed to invoke the method "
            + methodName + " in the service " + getInterface().getName()
            + ". Tried " + len + " times of the providers " + providers
            + " (" + providers.size() + "/" + copyInvokers.size()
            + ") from the registry " + directory.getUrl().getAddress()
            + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version "
            + Version.getVersion() + ". Last error is: "
            + le.getMessage(), le.getCause() != null ? le.getCause() : le);
}
```

#### 获取最合适的服务流程

选择Invoker的方法

1. 首先根据loadbalance进行选择，如果invoker在以前选择的列表中或invoker不能提供服务进行reselect。  
2. 重选的验证规则：selected>available，这个规则保证选中的invoker是在以前选中的列表中最小变动的，也保证了其适用性。

```java
protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation,
                        List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
// 判空检查
if (CollectionUtils.isEmpty(invokers)) {
    return null;
}
String methodName = invocation == null ? StringUtils.EMPTY : invocation.getMethodName();
// 判断请求的方法为粘滞连接
boolean sticky = invokers.get(0).getUrl()
        .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);

//检测invokers列表是否包含stickyInvoker。如果不包含，说明stickyInvoker代表的服务提供者挂了，此时需要将其置为空
if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {
    stickyInvoker = null;
}
// 在sticky为true且stickyInvoker!=null的情况下，如果selected包含stickeyInvoker,表明stickeyInvoker对应的服务提供者可能因为网络原因未能成功提供服务，但是该提供者并没挂，此时invokers列表中仍存在该服务提供者对应的Invoker
if (sticky && stickyInvoker != null && (selected == null || !selected.contains(stickyInvoker))) {
    // availablecheck表示是否开启了可用性检查，如果开启了，则调用stickyInvoker的isAvailable方法进行检查，若果检查通过，则直接返回stickyInvoker
    if (availablecheck && stickyInvoker.isAvailable()) {
        return stickyInvoker;
    }
}

// 粘性连接为null或者不可用，需要进行重现选择
Invoker<T> invoker = doSelect(loadbalance, invocation, invokers, selected);
// 如果sticky为true，将负载均衡组件选择的Invoker赋值给stickyInvoker
if (sticky) {
    stickyInvoker = invoker;
}
    return invoker;
}
```

选择Invoker

```java
private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,
                            List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
    // 判空检查
    if (CollectionUtils.isEmpty(invokers)) {
        return null;
    }
    if (invokers.size() == 1) {
        return invokers.get(0);
    }
    // 通过负载均衡选择Invoker
    Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);

    // 如果selected包含负载均衡选择出的Invoker,或者该Invoker无法经过可用性检查，此时进行重选
    if ((selected != null && selected.contains(invoker))
            || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
        try {
            // 进行重选
            Invoker<T> rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
            if (rInvoker != null) {
                invoker = rInvoker;
            } else {
                //获取Invoker在Invokers中的位置
                int index = invokers.indexOf(invoker);
                try {
                    //获取index+1位置处的Invoker
                    invoker = invokers.get((index + 1) % invokers.size());
                } catch (Exception e) {
                    logger.warn(e.getMessage() + " may because invokers list dynamic change, ignore.", e);
                }
            }
        } catch (Throwable t) {
            logger.error("cluster reselect fail reason is :" + t.getMessage() + " if can not solve, you can set cluster.availablecheck=false in url", t);
        }
    }
    return invoker;
}
```

重现进行选择 

```java
private Invoker<T> reselect(LoadBalance loadbalance, Invocation invocation,
                            List<Invoker<T>> invokers, List<Invoker<T>> selected, boolean availablecheck) throws RpcException {

    //Allocating one in advance, this list is certain to be used.
    List<Invoker<T>> reselectInvokers = new ArrayList<>(
            invokers.size() > 1 ? (invokers.size() - 1) : invokers.size());

    // 尝试不从selected中获取
    for (Invoker<T> invoker : invokers) {
        // 检查可用性
        if (availablecheck && !invoker.isAvailable()) {
            continue;
        }
        // 如果selected列表包含当前invoker，则将其添加到reselectInvokers中。
        if (selected == null || !selected.contains(invoker)) {
            reselectInvokers.add(invoker);
        }
    }
    // reselectInvoker不为空，通过负载均衡组件进行筛选Invoker
    if (!reselectInvokers.isEmpty()) {
        return loadbalance.select(reselectInvokers, getUrl(), invocation);
    }
    // 仅从selected中查找能用的Invoker
   // selected 列表中查找可用的 Invoker，并将其添加到 reselectInvokers 集合中
    if (selected != null) {
        for (Invoker<T> invoker : selected) {
            if ((invoker.isAvailable()) // available first
                    && !reselectInvokers.contains(invoker)) {
                reselectInvokers.add(invoker);
            }
        }
    }
    if (!reselectInvokers.isEmpty()) {
        // 在此进行筛选，返回结果
        return loadbalance.select(reselectInvokers, getUrl(), invocation);
    }

    return null;
}
```

目的选择合适的Invoker执行，如何选择？

1. 获取所有的服务实现者。
2. 从所有的服务中选择出合适的实现者。
3. 选择粘滞连接的实现者。
4. Invoker的唯一，就选择这个Invoker。
5. loadbalance组件进行选择。

####  参考

```markdown
[Dubbo](http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html)
```

