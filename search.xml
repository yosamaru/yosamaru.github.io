<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dubbo Cluster如何获取最优的服务提供者？</title>
    <url>/2020/05/19/20001/</url>
    <content><![CDATA[<blockquote>
<p>Cluster的核心功能之一就是寻找出合适的服务提供者，供消费者远程调用。<br>如何寻找：</p>
<ol>
<li><p>获取消费者能够远程调用的所有服务提供者列表。</p>
</li>
<li><p>选择合适的Invoker。</p>
</li>
<li><p>如果只有一个Invoker则直接返回，有多个Invoker，则通过loadbalance组件选择出合适的Invoker。 </p>
 <a id="more"></a>
</li>
</ol>
</blockquote>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Invocation：会话域，它持有调用过程中的变量，比如方法名，参数等。<br>Invoker:实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>集群 Cluster 用途是将多个服务提供者合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者。以Failover Cluster为基础了解Cluster执行</p>
<p> Cluster：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(FailoverCluster.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge the directory invokers to a virtual invoker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cluster invoker  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failover"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并返回FailoverClusterInvoker</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;T&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Cluster获取Invoker流程"><a href="#Cluster获取Invoker流程" class="headerlink" title="Cluster获取Invoker流程"></a>Cluster获取Invoker流程</h4><p>AbstractClusterInvoker:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line">    <span class="comment">// binding attachments into invocation.</span></span><br><span class="line">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">    <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 列举invoker</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">    <span class="comment">// 加载LoadBalance </span></span><br><span class="line">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FailoverClusterInvoker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">    <span class="comment">// invokers判空检查</span></span><br><span class="line">    checkInvokers(copyInvokers, invocation);</span><br><span class="line">          <span class="comment">// 获取访问的方法</span></span><br><span class="line">    String methodName = RpcUtils.getMethodName(invocation);    </span><br><span class="line">    <span class="comment">// 重试次数</span></span><br><span class="line">    <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// retry loop.</span></span><br><span class="line">    RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在进行重试前重新列举Invoker，这样做的好数是如果某个服务挂了，通过调用list可得到最新可用的Invoker列表</span></span><br><span class="line">            checkWhetherDestroyed();</span><br><span class="line">            copyInvokers = list(invocation);</span><br><span class="line">            <span class="comment">// check again</span></span><br><span class="line">            checkInvokers(copyInvokers, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 通过负载均衡选择invoker</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">        <span class="comment">// 添加invoker到invoked 列表中</span></span><br><span class="line">        invoked.add(invoker);</span><br><span class="line">        <span class="comment">// 设置invoked到RPC上下文中</span></span><br><span class="line">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用目标Invoker的invoke方法</span></span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Although retry the method "</span> + methodName</span><br><span class="line">                        + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">                        + <span class="string">" was successful by the provider "</span> + invoker.getUrl().getAddress()</span><br><span class="line">                        + <span class="string">", but there have been failed providers "</span> + providers</span><br><span class="line">                        + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">                        + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">                        + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                        + <span class="string">" using the dubbo version "</span> + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">                        + le.getMessage(), le);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            le = e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            providers.add(invoker.getUrl().getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">"Failed to invoke the method "</span></span><br><span class="line">            + methodName + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">            + <span class="string">". Tried "</span> + len + <span class="string">" times of the providers "</span> + providers</span><br><span class="line">            + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">            + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">            + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" using the dubbo version "</span></span><br><span class="line">            + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">            + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取最合适的服务流程"><a href="#获取最合适的服务流程" class="headerlink" title="获取最合适的服务流程"></a>获取最合适的服务流程</h4><p>选择Invoker的方法</p>
<ol>
<li>首先根据loadbalance进行选择，如果invoker在以前选择的列表中或invoker不能提供服务进行reselect。  </li>
<li>重选的验证规则：selected&gt;available，这个规则保证选中的invoker是在以前选中的列表中最小变动的，也保证了其适用性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                        List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"><span class="comment">// 判空检查</span></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String methodName = invocation == <span class="keyword">null</span> ? StringUtils.EMPTY : invocation.getMethodName();</span><br><span class="line"><span class="comment">// 判断请求的方法为粘滞连接</span></span><br><span class="line"><span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">        .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测invokers列表是否包含stickyInvoker。如果不包含，说明stickyInvoker代表的服务提供者挂了，此时需要将其置为空</span></span><br><span class="line"><span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">    stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在sticky为true且stickyInvoker!=null的情况下，如果selected包含stickeyInvoker,表明stickeyInvoker对应的服务提供者可能因为网络原因未能成功提供服务，但是该提供者并没挂，此时invokers列表中仍存在该服务提供者对应的Invoker</span></span><br><span class="line"><span class="keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="keyword">null</span> &amp;&amp; (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">    <span class="comment">// availablecheck表示是否开启了可用性检查，如果开启了，则调用stickyInvoker的isAvailable方法进行检查，若果检查通过，则直接返回stickyInvoker</span></span><br><span class="line">    <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 粘性连接为null或者不可用，需要进行重现选择</span></span><br><span class="line">Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line"><span class="comment">// 如果sticky为true，将负载均衡组件选择的Invoker赋值给stickyInvoker</span></span><br><span class="line"><span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">    stickyInvoker = invoker;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择Invoker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 判空检查</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过负载均衡选择Invoker</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果selected包含负载均衡选择出的Invoker,或者该Invoker无法经过可用性检查，此时进行重选</span></span><br><span class="line">    <span class="keyword">if</span> ((selected != <span class="keyword">null</span> &amp;&amp; selected.contains(invoker))</span><br><span class="line">            || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="keyword">null</span> &amp;&amp; availablecheck)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行重选</span></span><br><span class="line">            Invoker&lt;T&gt; rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br><span class="line">            <span class="keyword">if</span> (rInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                invoker = rInvoker;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取Invoker在Invokers中的位置</span></span><br><span class="line">                <span class="keyword">int</span> index = invokers.indexOf(invoker);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取index+1位置处的Invoker</span></span><br><span class="line">                    invoker = invokers.get((index + <span class="number">1</span>) % invokers.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage() + <span class="string">" may because invokers list dynamic change, ignore."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"cluster reselect fail reason is :"</span> + t.getMessage() + <span class="string">" if can not solve, you can set cluster.availablecheck=false in url"</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重现进行选择 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">reselect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected, <span class="keyword">boolean</span> availablecheck)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Allocating one in advance, this list is certain to be used.</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; reselectInvokers = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">            invokers.size() &gt; <span class="number">1</span> ? (invokers.size() - <span class="number">1</span>) : invokers.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试不从selected中获取</span></span><br><span class="line">    <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">        <span class="comment">// 检查可用性</span></span><br><span class="line">        <span class="keyword">if</span> (availablecheck &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果selected列表包含当前invoker，则将其添加到reselectInvokers中。</span></span><br><span class="line">        <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) &#123;</span><br><span class="line">            reselectInvokers.add(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reselectInvoker不为空，通过负载均衡组件进行筛选Invoker</span></span><br><span class="line">    <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅从selected中查找能用的Invoker</span></span><br><span class="line">   <span class="comment">// selected 列表中查找可用的 Invoker，并将其添加到 reselectInvokers 集合中</span></span><br><span class="line">    <span class="keyword">if</span> (selected != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((invoker.isAvailable()) <span class="comment">// available first</span></span><br><span class="line">                    &amp;&amp; !reselectInvokers.contains(invoker)) &#123;</span><br><span class="line">                reselectInvokers.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 在此进行筛选，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目的选择合适的Invoker执行，如何选择？</p>
<ol>
<li>获取所有的服务实现者。</li>
<li>从所有的服务中选择出合适的实现者。</li>
<li>选择粘滞连接的实现者。</li>
<li>Invoker的唯一，就选择这个Invoker。</li>
<li>loadbalance组件进行选择。</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Dubbo</span>](<span class="link">http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>Cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security认证流程概述（一）</title>
    <url>/2020/05/06/20002/</url>
    <content><![CDATA[<blockquote>
<p>Spring Security是一个框架，提供针对常见攻击的身份验证，授权和保护。通过对命令式和反应式应用程序的一流支持，它是保护基于Spring的应用程序的事实标准。本章只是对Spring Security 认证流程的一个大概的认知！<a id="more"></a></p>
</blockquote>
<pre><code>##  Spring Security模块
</code></pre><ol>
<li><p>核心模块：包含核心的验证和访问控制类和接口，远程支持和基本的配置API。</p>
</li>
<li><p>远程调用：提供Spring Remoting的集成。</p>
</li>
<li><p>网页：包括网站安全的模块，提供网站认证服务和基于URL访问控制。</p>
</li>
<li><p>配置：包含安全命令空间的解析代码。</p>
</li>
<li><p>LDAP：LDAP验证和配置代码。主要用于LDAP验证和管理LDAP用户实体</p>
</li>
<li><p>ACL访问控制表：ACL专门的领域对象的实现。主要用于在程序中应用安全特定的领域对象实例。</p>
</li>
<li><p>CAS：Spring Security的CAS客户端集成。主要用于CAS的SSO服务器使用Spring Security网页验证需要该模块。</p>
</li>
<li><p>OpenID：OpenID 网页验证支持。使用外部的OpenID服务器验证用户。</p>
</li>
<li><p>Test：支持Spring Security的测试。</p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/2020/05/06/20002/20002.png" alt="Spring Security认证流程"></p>
<ol>
<li><p>输入用户名、密码后点击登录按钮，先进入 UsernamePassworkAuthenticationFilter 的父类<br>AbstractAuthenticationProcessingFilter 调用 doFilter() 方法，然后再执行 UsernamePasswordAuthenticationFilter 的 attemptAuthentication() 方法进行验证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest)req;</span><br><span class="line">    HttpServletResponse response = (HttpServletResponse)res;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.requiresAuthentication(request, response)) &#123;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Request is to process authentication"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Authentication authResult;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行认证流程</span></span><br><span class="line">            authResult = <span class="keyword">this</span>.attemptAuthentication(request, response);</span><br><span class="line">            <span class="keyword">if</span> (authResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException var8) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.error(<span class="string">"An internal error occurred while trying to authenticate the user."</span>, var8);</span><br><span class="line">            <span class="keyword">this</span>.unsuccessfulAuthentication(request, response, var8);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException var9) &#123;</span><br><span class="line">            <span class="keyword">this</span>.unsuccessfulAuthentication(request, response, var9);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//认证成功</span></span><br><span class="line">        <span class="keyword">this</span>.successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>通过UsernamePasswordAuthenticationFilter过滤器将传入的username和password组装成UsernamePasswordAuthenticationToken对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">username = username.trim();</span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line"><span class="keyword">this</span>.setDetails(request, authRequest);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将UsernamePasswordAuthenticationToken传递到AuthenticationManager的anthenticate方法。</p>
</li>
<li><p>AuthenticationManager委托给ProviderManager的authencate方法进行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">    <span class="comment">//过滤掉测试模块类</span></span><br><span class="line">   <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Authentication attempt using "</span></span><br><span class="line">            + provider.getClass().getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">         copyDetails(authentication, result);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (AccountStatusException e) &#123;      prepareException(e, authentication);</span><br><span class="line">      <span class="comment">// SEC-546: Avoid polling additional providers if auth failure is due to</span></span><br><span class="line">      <span class="comment">// invalid account status</span></span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (InternalAuthenticationServiceException e) &#123;</span><br><span class="line">      prepareException(e, authentication);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">      lastException = e;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ProviderManager将authentication传递给AbstractUserDetailAuthenticationProvider的authenticate方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">   cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取UserDetails</span></span><br><span class="line">      user = retrieveUser(username,</span><br><span class="line">            (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">      logger.debug(<span class="string">"User '"</span> + username + <span class="string">"' not found"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line">               <span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line">               <span class="string">"Bad credentials"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> notFound;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Assert.notNull(user,</span><br><span class="line">         <span class="string">"retrieveUser returned null - a violation of the interface contract"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 在用户名密码验证之前进行的预操作</span></span><br><span class="line">   preAuthenticationChecks.check(user);</span><br><span class="line">   additionalAuthenticationChecks(user,</span><br><span class="line">         (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line">   <span class="keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">      <span class="comment">// There was a problem, so try again after checking</span></span><br><span class="line">      <span class="comment">// we're using latest data (i.e. not from the cache)</span></span><br><span class="line">      cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line">      user = retrieveUser(username,</span><br><span class="line">            (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">      preAuthenticationChecks.check(user);</span><br><span class="line">      additionalAuthenticationChecks(user,</span><br><span class="line">            (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> exception;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">   <span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">   principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回认证成功的用户信息（Authentication）</span></span><br><span class="line"><span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br></pre></td></tr></table></figure>
</li>
<li><p>AbstractUserDetailAuthenticationProvider的additionalAuthenticationChecks进行用户名与密码的验证，获取UserDetails通过其子类DaoAuthenticationProvider类实现。在DaoAuthenticationProvider中通过UserDetailsService的loadUserByUsername方法进行获取。而DaoAuthenticationProvider只是其最简单的一个实现。</p>
</li>
<li><p>当用户验证成功后，利用SecurityContextHolder用来存储安全的上下文信息。保存当前的访问者信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">       <span class="keyword">this</span>.logger.debug(<span class="string">"Authentication success. Updating SecurityContextHolder to contain: "</span> + authResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证成功后，将用户信息保存到SecurityContextHolder中</span></span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">    <span class="keyword">this</span>.rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.eventPublisher != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.eventPublisher.publishEvent(<span class="keyword">new</span> InteractiveAuthenticationSuccessEvent(authResult, <span class="keyword">this</span>.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主要接口释义"><a href="#主要接口释义" class="headerlink" title="主要接口释义"></a>主要接口释义</h2><h4 id="Authentication验证信息"><a href="#Authentication验证信息" class="headerlink" title="Authentication验证信息"></a>Authentication验证信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//权限信息列表，默认是GrantedAuthority接口的一些实现类。通常是代表权限的一系列字符串。</span></span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="comment">//密码信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。</span></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 详细信息，web应用中的实现接口通常为WebAuthenticationDetails，它记录了访问者的ip地址和sessionID的值。</span></span><br><span class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 身份信息，大部分情况下返回的是UserDetails接口的实现类。在未认证的情况下获取到的是用户名，在已认证的情况下获取到的是UserDetails。</span></span><br><span class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取当前Authentication是否已认证。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 设置当前Authentication是否已认证。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UserDetails用户核心信息"><a href="#UserDetails用户核心信息" class="headerlink" title="UserDetails用户核心信息"></a>UserDetails用户核心信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取用户权限，本质是用户的校色信息</span></span><br><span class="line">   Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="comment">//获取密码</span></span><br><span class="line">   <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取用户名</span></span><br><span class="line">   <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//账户是否过期</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//账户是否被锁定</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//密码是否过期</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//账户是否可用</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo的SPI的机制初探</title>
    <url>/2020/05/10/20003/</url>
    <content><![CDATA[<blockquote>
<p>SPI 模式在开发中用到的地方很多，但是一直和Dubbo的SPI混淆在一起，本文对JDK的SPI和Dubbo的SPI区分的一个概念的大略了解，为了后取对Dubbo框架的熟悉做一个基础。<a id="more"></a></p>
</blockquote>
<h2 id="什么是SPI？"><a href="#什么是SPI？" class="headerlink" title="什么是SPI？"></a>什么是SPI？</h2><p>SPI的全称是Service Provider Interface，用来被第三方实现或者扩展的API。也就是说SPI是一种服务发现机制。而对于我的理解就是：SPI是为某个接口寻找实现类的机制，有点类似于IOC，用于解耦。</p>
<h3 id="JDK-SPI"><a href="#JDK-SPI" class="headerlink" title="JDK SPI"></a>JDK SPI</h3><p>SPI具体约定：当服务的提供者，提供了一种服务之后，在jar包的META-INF/Services/目录里同时创建一个以服务接口全路径命名的文件，该文件里就是实现该服务的接口的具体命名的实现类。当第三方服务需要引入这个模块的时候，就可以通过该jar包的MATE-INF/Services/里的配置文件找到具体的实现类名，通过JDK提供的工具类java.util.ServiceLoader进行加载实例化。</p>
<p>最常见的就是数据库驱动包，以mysql为例，正如上面所讲的一样，在META-INF/Services/目录下创建以java.sql.Driver文件，文件中是接口的具体实现类。</p>
<p><img src="/2020/05/10/20003/SPI-mysql.png" alt="MySQL SPI配置"></p>
<p>而配置文件中具体的实现类如下：</p>
<p><img src="/2020/05/10/20003/SPI-mysql2.png" alt="MySQL 驱动具体实现类"></p>
<h2 id="Dubbo的SPI"><a href="#Dubbo的SPI" class="headerlink" title="Dubbo的SPI"></a>Dubbo的SPI</h2><h3 id="Dubbo-SPI约定"><a href="#Dubbo-SPI约定" class="headerlink" title="Dubbo SPI约定"></a>Dubbo SPI约定</h3><p>dubbo的SPI加载类和JDK的SPI记载类不同， dubbo的记载类org.apache.dubbo.common.extension.ExtensionLoader，进入源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 兼容了JDK SPI的配置文件放置位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICES_DIRECTORY = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_DIRECTORY = <span class="string">"META-INF/dubbo/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + <span class="string">"internal/"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized in getExtensionClasses</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    cacheDefaultExtensionName();</span><br><span class="line">		<span class="comment">// 加载配置文件约定放置的位置</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面两段源码可知，在Dubbo启动的时候，会默认扫描META/-INF/services、META-INF/dubbo/、META-INF/dubbo/internal三个目录，其实Dubbo的SPI和JDK SPI类似，同样需要在以上三个目录中放置以全路径名为命名的配置文件，而配置文件的内容为key=扩展节点实现的全路径名，如果由多个实现类则使用换行符分割。key会作为Dubbo SPI注解中的传入参数。</p>
<h3 id="SPI的缓存"><a href="#SPI的缓存" class="headerlink" title="SPI的缓存"></a>SPI的缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展类与对应的扩展类加载起缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展名与类初始化后的缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExtensionFactory objectFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展类与扩展名缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通扩展类缓存，不包括自适应的拓展类和Wrapper</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line"><span class="comment">// 扩展名与@Activate的缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 扩展名与扩展对象缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 实例化后的自适应扩展对象，只能同时存在一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line"><span class="comment">// 自适应扩展类缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> String cachedDefaultName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Throwable createAdaptiveInstanceError;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Wrapper类缓存</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br></pre></td></tr></table></figure>
<p>由上面源码可以明确的分为Class缓存，实例缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addExtension</span><span class="params">(String name, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 1. 加载Class</span></span><br><span class="line">    getExtensionClasses(); <span class="comment">// load classes</span></span><br><span class="line">		<span class="comment">// 2. Class 判断</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Input type "</span> +</span><br><span class="line">                clazz + <span class="string">" doesn't implement the Extension "</span> + type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Input type "</span> +</span><br><span class="line">                clazz + <span class="string">" can't be interface!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension name is blank (Extension "</span> + type + <span class="string">")!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// Class 缓存中是否已经有该Class类</span></span><br><span class="line">        <span class="keyword">if</span> (cachedClasses.get().containsKey(name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension name "</span> +</span><br><span class="line">                    name + <span class="string">" already exists (Extension "</span> + type + <span class="string">")!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 将要加载的扩展类的名字进行保存（即使扩展类获取不到，也可以知道是哪个扩展类没有获取到）</span></span><br><span class="line">        cachedNames.put(clazz, name);</span><br><span class="line">      	<span class="comment">// 将Class文件存入缓存</span></span><br><span class="line">        cachedClasses.get().put(name, clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Adaptive Extension already exists (Extension "</span> + type + <span class="string">")!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cachedAdaptiveClass = clazz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载Class</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">  			<span class="comment">// 1.1 从Class缓存中获取Class</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">  			<span class="comment">// 1.2 Class 不存在</span></span><br><span class="line">        <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">              	<span class="comment">// 防止重复获取</span></span><br><span class="line">                classes = cachedClasses.get();</span><br><span class="line">                <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  	<span class="comment">// 1.3 从配置中加载Class类</span></span><br><span class="line">                    classes = loadExtensionClasses();</span><br><span class="line">                  	<span class="comment">// 1.4 缓存中保存Class类</span></span><br><span class="line">                    cachedClasses.set(classes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">// 1.5 返回Class类</span></span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Class缓存优先从缓存中读取，如果缓存中不存在，则加载配置文件，根据配置把Class缓存到内存中，但并不会全部初始化，会按需初始化。</p>
</li>
<li><p>实例缓存每次获取的时候，会先从缓存中获取，如果缓存中读取不到，则重新加载缓存起来。</p>
</li>
</ol>
<p>而Class缓存和实例缓存根据其特性又可以分为普通扩展类、包装扩展类、自适应扩展类、其他缓存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在官方文档中两者的比较如下：</p>
<ol>
<li>JDK标准的SPI会一次性实例化扩展的所有实现，即使内有用上也会加载。</li>
<li>如果加载失败，则连扩展的名称都获取不到。</li>
<li>增加了对扩展IoC和AOP的支持，一个扩展可以直接setter注入其他扩展。</li>
</ol>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo的负载均衡算法学习</title>
    <url>/2020/06/06/20004/</url>
    <content><![CDATA[<blockquote>
<p>Dubbo的Cluter会选择最合适的服务，供调用者使用。如何选取？  </p>
<ol>
<li>ConsistentHash，Ketama一致性哈希算法。</li>
<li>Rondom，随机获取。</li>
<li>Roundbin，轮询选择。</li>
<li>leastActive，选择最近最少使用的节点。 <a id="more"></a>  
</li>
</ol>
</blockquote>
<h2 id="AbastractLoadBlance"><a href="#AbastractLoadBlance" class="headerlink" title="AbastractLoadBlance"></a>AbastractLoadBlance</h2><p>Dubbo各个模块都是通过模版模式进行灵活适配，路由模块也不例外。</p>
<p>AbastractLoadBlance实现LoadBalance接口，进行基础处理，如：权重获取、只有一个Invoker时，直接返回。</p>
<h3 id="模版处理"><a href="#模版处理" class="headerlink" title="模版处理"></a>模版处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 只存在一个服务节点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模板方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当有多个服务节点时，就需要同过选择的路由算法获取出合适的节点。doSelect模版方法的由对应的路由算法实现自己的特俗化处理。</p>
<p><img src="/2020/06/06/20004/AbstractLoadBalance.png" alt="路由类结构关系图"></p>
<h3 id="权重获取"><a href="#权重获取" class="headerlink" title="权重获取"></a>权重获取</h3><p>权重的获取至关重要，Consisten Hash、Roundbin、Rondom、LeastActive都需要获取权重参与计算。  </p>
<ul>
<li><p>获取对每个服务自定以的权重。如果没有配置，使用默认配置。</p>
</li>
<li><p>获取预热时间（nowTime-startTime）、总预热时间。</p>
</li>
<li><p>计算权重。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取权重</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 通过URL获取当前Invoker设置的权重</span></span><br><span class="line">    <span class="keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">    <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 获取启动的时间节点</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">						<span class="comment">// 求差值，得到已经预热时间</span></span><br><span class="line">            <span class="keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span><br><span class="line">            <span class="keyword">if</span> (uptime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 获取设置的总预热时间</span></span><br><span class="line">            <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span><br><span class="line">            <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">								<span class="comment">// 计算出最后的权重</span></span><br><span class="line">                weight = calculateWarmupWeight((<span class="keyword">int</span>)uptime, warmup, weight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(weight, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>权重计算：（启动至今的时间/  给予的预热总时间）* 权重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ww = (<span class="keyword">int</span>) ( uptime / ((<span class="keyword">float</span>) warmup / weight));</span><br><span class="line">    <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (Math.min(ww, weight));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Consistent-Hash"><a href="#Consistent-Hash" class="headerlink" title="Consistent Hash"></a>Consistent Hash</h2><p>Consistent Hash负载均衡可以让参数相同的请求每次路由到相同的机器上。</p>
<p>Ketama算法会为每个真实节点在创建多个虚拟节点，让节点在环形上的分布更加均匀，后续的调用也会随之更加均匀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="keyword">int</span> identityHashCode) &#123;</span><br><span class="line">    <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">    URL url = invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line">    <span class="keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="number">160</span>);</span><br><span class="line">    String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="string">"0"</span>));</span><br><span class="line">    argumentIndex = <span class="keyword">new</span> <span class="keyword">int</span>[index.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">        argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 遍历所有的节点</span></span><br><span class="line">    <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">				<span class="comment">// 获得每个节点的IP</span></span><br><span class="line">        String address = invoker.getUrl().getAddress();</span><br><span class="line">				<span class="comment">// replicaNumber是生成的虚拟节点数，默认为160个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">						<span class="comment">// 以IP+递增数字做MD5，以此作为节点标识</span></span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(address + i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line">								<span class="comment">// 对标识做“Hash”得到TreeMap的Key，以Invoker为value</span></span><br><span class="line">                virtualInvokers.put(m, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round Robin"></a>Round Robin</h2><p>权重轮询负载均衡会根据设置的权重来判断轮询的比例。</p>
<p>普通轮训负载均衡好处是每个节点获得的请求会很均匀，如果某些节点的负载能力很弱，则这个节点会堆积较多的请求。所以需要根据节点权重进行干预。</p>
<p>权重轮训</p>
<p>普通权重轮训：会造成某个节点突然被频繁选中，易造成某个节点流量暴增。</p>
<p>平滑权重轮训：在轮训时穿插训责其他节点，让整个服务器选择的过程比较均匀。</p>
<p>Dubbo的RoundRobin负载均衡算法采用的就是平滑权重轮训算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 生成key</span></span><br><span class="line">    String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</span><br><span class="line">		<span class="comment">// 查看缓存中是否存在</span></span><br><span class="line">    ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 不存在，重新生成WeightedRoundRobin</span></span><br><span class="line">        methodWeightMap.putIfAbsent(key, <span class="keyword">new</span> ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;());</span><br><span class="line">        map = methodWeightMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 权重总和</span></span><br><span class="line">    <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 最大的Current，默认为最小值</span></span><br><span class="line">    <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    Invoker&lt;T&gt; selectedInvoker = <span class="keyword">null</span>;</span><br><span class="line">    WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 遍历服务提供者，获取权重</span></span><br><span class="line">    <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">        String identifyString = invoker.getUrl().toIdentityString();</span><br><span class="line">        WeightedRoundRobin weightedRoundRobin = map.get(identifyString);</span><br><span class="line">			<span class="comment">/**************************************************************/</span></span><br><span class="line">			<span class="comment">/**************************************************************/</span></span><br><span class="line">			<span class="comment">/********将所有的Invoker的权重封装成WeightedRoundRobin对象**********/</span></span><br><span class="line">			<span class="comment">/**************************************************************/</span></span><br><span class="line">			<span class="comment">/**************************************************************/</span></span><br><span class="line">				<span class="comment">// 获取预热权重</span></span><br><span class="line">        <span class="keyword">int</span> weight = getWeight(invoker, invocation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (weightedRoundRobin == <span class="keyword">null</span>) &#123;</span><br><span class="line">            weightedRoundRobin = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">            weightedRoundRobin.setWeight(weight);</span><br><span class="line">            map.putIfAbsent(identifyString, weightedRoundRobin);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 如果预热权重和和invoker设置的权重不相等，说明还在预热阶段，此时以预热权重为准。</span></span><br><span class="line">        <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">            <span class="comment">//weight changed</span></span><br><span class="line">            weightedRoundRobin.setWeight(weight);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 平滑轮询</span></span><br><span class="line">				<span class="comment">// 每个invoker会把权重加到自己的current属性上，并更新当前invoekr的lastUpdate属性。</span></span><br><span class="line">				<span class="comment">// current = current + weight;</span></span><br><span class="line">        <span class="keyword">long</span> cur = weightedRoundRobin.increaseCurrent();</span><br><span class="line">				<span class="comment">// 设置最后一次更新时间</span></span><br><span class="line">        weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">				<span class="comment">// 选取current最大的节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">            maxCurrent = cur;</span><br><span class="line">            selectedInvoker = invoker;</span><br><span class="line">            selectedWRR = weightedRoundRobin;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 累加每个Invoker的权重</span></span><br><span class="line">        totalWeight += weight;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 根据权重更新缓存</span></span><br><span class="line">		<span class="comment">// 由于所有的Invoker都会封装成为weightedRoundRobin对象，</span></span><br><span class="line">    <span class="comment">// 因为可以调用的invoker数量和缓存weightedRoundRobin对象的Map大小不相等，则说明缓存中有无用的数据。</span></span><br><span class="line">    <span class="keyword">if</span> (!updateLock.get() &amp;&amp; invokers.size() != map.size()) &#123;</span><br><span class="line">				<span class="comment">// 利用CAS抢占锁</span></span><br><span class="line">        <span class="keyword">if</span> (updateLock.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// copy -&gt; modify -&gt; update reference</span></span><br><span class="line">                ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(map);</span><br><span class="line">                <span class="comment">// 根据lastUpdate更新过期数据</span></span><br><span class="line">								newMap.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">                <span class="comment">// 修改指针引用</span></span><br><span class="line">								methodWeightMap.put(key, newMap);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                updateLock.set(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 返回Invoker。将当前Invoker的current减去总权重。</span></span><br><span class="line">    <span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        selectedWRR.sel(totalWeight);</span><br><span class="line">        <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// should not happen here</span></span><br><span class="line">    <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WeightedRoundRobin"><a href="#WeightedRoundRobin" class="headerlink" title="WeightedRoundRobin"></a>WeightedRoundRobin</h3><p>权重的计算与原子保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedRoundRobin</span> </span>&#123;</span><br><span class="line">		<span class="comment">// invoker设定的权重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">		<span class="comment">// 考虑到并发场景下某个Invoker会被同时选中，表示该节点被所有线程选中的权重总和</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong current = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 最后一次更新时间，用于后续缓存超时的判断</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastUpdate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        current.set(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sel</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastUpdate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdate</span><span class="params">(<span class="keyword">long</span> lastUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>Random负载均衡是按照权重设置随机概率做负载均衡。 </p>
<ul>
<li><p>求出invokers权重总和。</p>
</li>
<li><p>根据总权重计算出一个随机的偏移量。</p>
</li>
<li><p>偏移量轮循键每个invoker的权重，如果偏移量小于0，就选中当前Invoeker。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Number of invokers</span></span><br><span class="line">    <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">    <span class="comment">// Every invoker has the same weight?</span></span><br><span class="line">		<span class="comment">// 所有invoker拥有相同的权重</span></span><br><span class="line">    <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// the weight of every invokers</span></span><br><span class="line">		<span class="comment">// 生命一个权重数组，用于存放所有invoker的权重</span></span><br><span class="line">    <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="comment">// the first invoker's weight</span></span><br><span class="line">		<span class="comment">// 获取第一个Invoker的权重</span></span><br><span class="line">    <span class="keyword">int</span> firstWeight = getWeight(invokers.get(<span class="number">0</span>), invocation);</span><br><span class="line">    weights[<span class="number">0</span>] = firstWeight;</span><br><span class="line">    <span class="comment">// The sum of weights</span></span><br><span class="line">		<span class="comment">// invokers权重总和</span></span><br><span class="line">    <span class="keyword">int</span> totalWeight = firstWeight;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">				<span class="comment">// 获取权重</span></span><br><span class="line">        <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">        <span class="comment">// save for later use</span></span><br><span class="line">        weights[i] = weight;</span><br><span class="line">        <span class="comment">// Sum</span></span><br><span class="line">				<span class="comment">// invokers权重进行加和</span></span><br><span class="line">        totalWeight += weight;</span><br><span class="line">				<span class="comment">// 判断invokers是否拥有相同的权重</span></span><br><span class="line">        <span class="keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">            sameWeight = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 所有的invoekr权重不同</span></span><br><span class="line">    <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">        <span class="comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span><br><span class="line">        <span class="comment">// 根据总权重计算出一个随机的偏移量，此处使用了ThreadLocalRandom性能会更好</span></span><br><span class="line">				<span class="keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">        <span class="comment">// Return a invoker based on the random value.</span></span><br><span class="line">				<span class="comment">// 遍历所有的Invoker，轮询减去权重。得到被选中的Invoker</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            offset -= weights[i];</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class="line">		<span class="comment">// 如果所有的权重相同，随机获取一个Invoker</span></span><br><span class="line">    <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Least-Active"><a href="#Least-Active" class="headerlink" title="Least Active"></a>Least Active</h2><p>Least Active负载均衡称为最少活动调用数负载均衡，框架会记下每个Invoker的活跃数，每次只取活跃数最少的Invoker。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Number of invokers</span></span><br><span class="line">    <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">    <span class="comment">// The least active value of all invokers</span></span><br><span class="line">    <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// The number of invokers having the same least active value (leastActive)</span></span><br><span class="line">    <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// The index of invokers having the same least active value (leastActive)</span></span><br><span class="line">    <span class="keyword">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="comment">// the weight of every invokers</span></span><br><span class="line">    <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="comment">// The sum of the warmup weights of all the least active invokers</span></span><br><span class="line">    <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// The weight of the first least active invoker</span></span><br><span class="line">    <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Every least active invoker has the same weight value?</span></span><br><span class="line">    <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter out all the least active invokers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">				<span class="comment">// 获得invoker的活跃数和预热权重</span></span><br><span class="line">        <span class="comment">// Get the active number of the invoker</span></span><br><span class="line">        <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">        <span class="comment">// Get the weight of the invoker's configuration. The default value is 100.</span></span><br><span class="line">        <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">        <span class="comment">// save for later use</span></span><br><span class="line">        weights[i] = afterWarmup;</span><br><span class="line">        <span class="comment">// 第一次执行或者发现更小的活跃数</span></span><br><span class="line">				<span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">						<span class="comment">// 置空之前的计数</span></span><br><span class="line">            <span class="comment">// Reset the active number of the current invoker to the least active number</span></span><br><span class="line">            leastActive = active;</span><br><span class="line">            <span class="comment">// Reset the number of least active invokers</span></span><br><span class="line">            leastCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// Put the first least active invoker first in leastIndexes</span></span><br><span class="line">            leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="comment">// Reset totalWeight</span></span><br><span class="line">            totalWeight = afterWarmup;</span><br><span class="line">            <span class="comment">// Record the weight the first least active invoker</span></span><br><span class="line">            firstWeight = afterWarmup;</span><br><span class="line">            <span class="comment">// Each invoke has the same weight (only one invoker here)</span></span><br><span class="line">            sameWeight = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// If current invoker's active value equals with leaseActive, then accumulating.</span></span><br><span class="line">						<span class="comment">// 当前invoker的活跃数和计数相同，说明N个invoker都是最小计数，全部保存到集合中后续就在它们里面根据权重选取一个。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line">            <span class="comment">// Record the index of the least active invoker in leastIndexes order</span></span><br><span class="line">            leastIndexes[leastCount++] = i;</span><br><span class="line">            <span class="comment">// Accumulate the total weight of the least active invoker</span></span><br><span class="line">            totalWeight += afterWarmup;</span><br><span class="line">            <span class="comment">// If every invoker has the same weight?</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Choose an invoker from all the least active invokers</span></span><br><span class="line">		<span class="comment">// 如果只有个invoker直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// If we got exactly one invoker having the least active value, return this invoker directly.</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果权重不一样，则使用和Random负载均衡一样的权重算法找到一个invoker并返回。</span></span><br><span class="line">    <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on </span></span><br><span class="line">        <span class="comment">// totalWeight.</span></span><br><span class="line">        <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">        <span class="comment">// Return a invoker based on the random value.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leastIndex = leastIndexes[i];</span><br><span class="line">            offsetWeight -= weights[leastIndex];</span><br><span class="line">            <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 如果权重相同随机选取一个返回。</span></span><br><span class="line">    <span class="comment">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class="line">    <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dubbo的负载均衡是围绕权重进行计算的：</p>
<ol>
<li><p>一致性哈希利用了目前ketama哈希算法，redis的集群方案也有使用到。</p>
</li>
<li><p>rondom以总权重为线，每个invoker的权重为段，随机从总权重中获取一个游标offset，判断offset位于那一段，就返回该invoker。</p>
</li>
<li>Roundbin使用平滑权重轮循的数学原理。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.notion.so/Dubbo-ca1fd67df519464583c4a240244e239b#57b1bedf8e2c48be9c92380ddd721ced/" target="_blank" rel="noopener">https://www.notion.so/Dubbo-ca1fd67df519464583c4a240244e239b#57b1bedf8e2c48be9c92380ddd721ced/</a></p>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾收集（一）</title>
    <url>/2018/04/29/gc01/</url>
    <content><![CDATA[<blockquote>
<p>&emsp;&emsp;在JVM中,进行垃圾回收首先要判断对象对象是否存活，在对不同生命周期的对象进行垃圾回收。在进行垃圾回收时，要根据需求进行垃圾回收算法的选择。（比如注重吞吐量）<a id="more"></a>  </p>
</blockquote>
<h5 id="如何判断对象存活"><a href="#如何判断对象存活" class="headerlink" title="如何判断对象存活"></a>如何判断对象存活</h5><table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">思想</th>
<th style="text-align:center">优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">引用计数算法</td>
<td style="text-align:center">给对象一个计数器，有人引用就加1,引用失效就减1。当计数器为0时，则对象不再被引用。</td>
<td style="text-align:center">优点：实现简单，判定效率高。缺点：很难解决对象之间相互循环调用的问题</td>
</tr>
<tr>
<td style="text-align:center">可达性分析算法</td>
<td style="text-align:center">以GC Roots为起点，当一个对象没有以GC Roots为起点的引用链时，则对象不再被引用</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>在jdk中引用分为强引用、软引用、弱引用、虚引用。  </p>
<table>
<thead>
<tr>
<th style="text-align:center">强引用</th>
<th style="text-align:center">软引用</th>
<th style="text-align:center">弱引用</th>
<th style="text-align:center">虚引用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用只要存在，就不会被回收</td>
<td style="text-align:center">在系统将要发生内存溢出时，对象将进入二次垃圾回收范围</td>
<td style="text-align:center">只能生存到下一次垃圾回收之前</td>
<td style="text-align:center">惟一的目的就是能在这个对像被收集器回收时收到一个系统的通知</td>
</tr>
</tbody>
</table>
<h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5><blockquote>
<p>&emsp;&emsp;在JVM中，可以把堆分为1/3的新生代和2/3的老生代。在将新生代按照8:2分为Eden区和Survivor区。而在Survivor区有按照1:1分为两个，记为from，to区。(各参数依据默认参数)<br><img src="/2018/04/29/gc01/heap.png" alt="&#39;堆的内存结构&#39;"><br>在新创建一个对象时，首先要对一个对象进行判断，是大对象还是一般的对象（需要占用连续的内存空间：如较长的字符串数组）。如果是大对象就会直接进入老年代，否则一般的对象都会进入Eden区。如下图所示：<br><img src="/2018/04/29/gc01/newObj.png" alt="&#39;对象建立的过程&#39;"><br>而对于垃圾收集器的选择具体如下图所示：<br><img src="/2018/04/29/gc01/gccollector.png" alt="&#39;垃圾收集器的组合&#39;"><br>我们需要针对不同的场合选择垃圾收集器。  </p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">Serial</th>
<th style="text-align:center">ParNew</th>
<th style="text-align:center">Parallel Scavenge</th>
<th style="text-align:center">Serial Old</th>
<th style="text-align:center">Parallel Old</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单线程的收集器，只会使用一个CPU或一条收集器去完成垃圾收集工作，并在在它进行垃圾收集时，必须暂停其他所有工作的线程</td>
<td style="text-align:center">Serial收集器的多线程版本，也同样要暂停其他工作线程。只有它能与CMS收集器配合。</td>
<td style="text-align:center">CMS等收集器注重缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge是达到一个可控制的吞吐量。主要适合在后台运算而不需要太多交互的任务</td>
<td style="text-align:center">单线程收集器，使用标记-整理算法。主要用来和JDK1.5及以前的版本中与Parallel Scavenge配合使用和作为CMS收集器的后备预案，在并发收集器发生Concurrent Mode Failure时使用</td>
<td style="text-align:center">使用了多线程和标记-整理算法，在注重吞吐量以及CPU资源敏感的场合优先考虑Parallel Scavenge和Parallel Old收集器</td>
</tr>
</tbody>
</table>
<ul>
<li>CMS(Currernt Mark Sweep)<br>CMS收集器采用“标记-清除”算法，从而达到以获取最短回收停顿时间的目标。它分为4个步骤：  <ul>
<li>初始标记<br>标记GC Roots能直接关联到的对象，速度很快。</li>
<li>并发标记<br>进行GC Roots Tracing的过程。</li>
<li>重新标记<br>为了修正并发标记时间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</li>
<li>并发清除<br>并发清除GC Roots不可达的对象。<br>优点：并发收集，低停顿。<br>缺点：1、CMS收集线对CPU资源非常敏感。<br>&emsp;&emsp;&emsp;2、CMS收集器无法处理浮动的垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。当出现Concurrent Mode Failure失败时，虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，停顿的时间会加长。<br>&emsp;&emsp;&emsp;3、“标记-清除”会产生大量的空间碎片。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>CMS</tag>
        <tag>Serial</tag>
        <tag>ParNew</tag>
        <tag>Parallel</tag>
        <tag>Scavenge</tag>
        <tag>Serial Old</tag>
        <tag>Parallel Old</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务设计</title>
    <url>/2020/08/13/2020081301/</url>
    <content><![CDATA[<blockquote>
<p>Spring提供了两种编程式事物管理的方法：</p>
<ol>
<li><p>使用TransactionTemplate或者TransactionalOperator. </p>
</li>
<li><p>直接实现TransactionManager接口.  </p>
</li>
</ol>
<p>如果是使用命令式编程，Spring推荐使用TransactionTemplate来完成编程式事务管理，如果是响应式编程，那么使用TransactionalOperator更加合适<a id="more"></a></p>
</blockquote>
<h1 id="TransactionTemplate"><a href="#TransactionTemplate" class="headerlink" title="TransactionTemplate"></a>TransactionTemplate</h1><p><img src="/2020/08/13/2020081301/TransactionTemplate.png" alt="TransactionTemplate"></p>
<p>TransactionTemplate的工作机制：实际上就是通过一个TransactionCallback封装了业务逻辑，然后TransactionTemplate会在事务的上下文中调用。而实际上有时候并不需要返回值，这种情况下，我们可以使用TransactionCallbackWithoutResult提代TransactionCallback。</p>
<h2 id="Eg1"><a href="#Eg1" class="headerlink" title="Eg1"></a>Eg1</h2><p>TransactionTemplate完成事务处理，通过实现TransactionCallback接口并在其doInTransaction方法完成业务处理，使用如下图：</p>
<p><img src="/2020/08/13/2020081301/transactionCallbackWithoutResult.png" alt="TransactionTemplate使用案例"></p>
<h2 id="TransactionTemplate-execute方法"><a href="#TransactionTemplate-execute方法" class="headerlink" title="TransactionTemplate#execute方法"></a>TransactionTemplate#execute方法</h2><p>TransactionTemplate是线程安全的，我们可以全局配置一个TransactionTemplate，然后所有的类都共享这个TransactionTemplate。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	Assert.state(<span class="keyword">this</span>.transactionManager != <span class="keyword">null</span>, <span class="string">"No PlatformTransactionManager set"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.transactionManager <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((CallbackPreferringPlatformTransactionManager) <span class="keyword">this</span>.transactionManager).execute(<span class="keyword">this</span>, action);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 1.通过事物管理器开启事物</span></span><br><span class="line">		TransactionStatus status = <span class="keyword">this</span>.transactionManager.getTransaction(<span class="keyword">this</span>);</span><br><span class="line">		T result;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//2.执行传入的业务逻辑</span></span><br><span class="line">			result = action.doInTransaction(status);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			<span class="comment">// Transactional code threw application exception -&gt; rollback</span></span><br><span class="line">			<span class="comment">// 出现异常，进行回滚</span></span><br><span class="line">			rollbackOnException(status, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// Transactional code threw unexpected exception -&gt; rollback</span></span><br><span class="line">			<span class="comment">//// 出现异常，进行回滚</span></span><br><span class="line">			rollbackOnException(status, ex);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(ex, <span class="string">"TransactionCallback threw undeclared checked exception"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 执行成功，提交事物</span></span><br><span class="line">		<span class="keyword">this</span>.transactionManager.commit(status);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#TransactionDefinition</p>
<p><img src="/2020/08/13/2020081301/RuleBasedTransactionAttribute.png" alt="事务的定义信息"></p>
<p>描述对事务的属性，比如事物的传播方式，事物的隔离级别。</p>
<p><img src="/2020/08/13/2020081301/transactionDefinition.png" alt="事务传播属性"></p>
<h1 id="TransactionManager接口"><a href="#TransactionManager接口" class="headerlink" title="TransactionManager接口"></a>TransactionManager接口</h1><h2 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h2><p><img src="/2020/08/13/2020081301/DataSourceTransactionManager.png" alt="事务管理器"></p>
<p>PlatformTransactionManager是命令式编程模型下Spring事物机制的中心接口，定义了完成一个事物必须的三个步骤。定义事物提交，回滚，获取事物状态的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AbstractPlatformTransactionManager"><a href="#AbstractPlatformTransactionManager" class="headerlink" title="AbstractPlatformTransactionManager"></a>AbstractPlatformTransactionManager</h2><p>SYNCHRONIZATION_ALWAYS：默认为0</p>
<p>SYNCHRONIZATION_ON_ACTUAL_TRANSACTION：默认为1 </p>
<p>SYNCHRONIZATION_NEVER：默认为2</p>
<p>transactionSynchronization</p>
<p>defaultTimeout</p>
<p>nestedTransactionAllowed</p>
<p>validateExistingTransaction</p>
<p>globalRollbackOnParticipationFailure</p>
<p>failEarlyOnGlobalRollbackOnly</p>
<p>failEarlyOnGlobalRollbackOnly</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache debug flag to avoid repeated checks.</span></span><br><span class="line">	<span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (definition == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">		definition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		<span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">		<span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, definition.getTimeout());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//--------------propagation_mandatory----------------------//</span></span><br><span class="line">	<span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">				<span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//----------------------propagation_required/propagation_requires_new/propagation_nested--------------------//</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		<span class="comment">// 把当前事务挂起并保存当前事务的事务属性</span></span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Creating new transaction with name ["</span> + definition.getName() + <span class="string">"]: "</span> + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			<span class="comment">// 初始化事务,钩子方法</span></span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			<span class="comment">// 初始化事务同步</span></span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Create "empty" transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">		<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">			logger.warn(<span class="string">"Custom isolation level specified but no actual transaction initiated; "</span> +</span><br><span class="line">					<span class="string">"isolation level will effectively be ignored: "</span> + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="comment">// 创建新事务,注意:transaction参数为null,所以这里创建的不是一个真正的事务</span></span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title">suspend</span><span class="params">(@Nullable Object transaction)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object suspendedResources = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//挂起事务,钩子方法</span></span><br><span class="line">				suspendedResources = doSuspend(transaction);</span><br><span class="line">			&#125;</span><br><span class="line">			String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(<span class="keyword">false</span>);</span><br><span class="line">			Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">boolean</span> wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(<span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(</span><br><span class="line">					suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			<span class="comment">// doSuspend failed - original transaction is still active...</span></span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Transaction active but no synchronization active.</span></span><br><span class="line">		Object suspendedResources = doSuspend(transaction);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Neither transaction nor synchronization active.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TransactionSynchronization&gt; <span class="title">doSuspendSynchronization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.获取当前线程的所有事务同步回调</span></span><br><span class="line">	List&lt;TransactionSynchronization&gt; suspendedSynchronizations =</span><br><span class="line">			TransactionSynchronizationManager.getSynchronizations();</span><br><span class="line">  <span class="comment">// 2.循环并挂起所有同步回调接口</span></span><br><span class="line">	<span class="keyword">for</span> (TransactionSynchronization synchronization : suspendedSynchronizations) &#123;</span><br><span class="line">		synchronization.suspend();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3.清除资源</span></span><br><span class="line">	TransactionSynchronizationManager.clearSynchronization();</span><br><span class="line">	<span class="keyword">return</span> suspendedSynchronizations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>TransactionStatus</p>
<p><img src="/2020/08/13/2020081301/TransactionStatus.png" alt=""></p>
<h1 id="TransactionSynchronizationManager同步事务"><a href="#TransactionSynchronizationManager同步事务" class="headerlink" title="TransactionSynchronizationManager同步事务"></a>TransactionSynchronizationManager同步事务</h1><p>TransactionSynchronizationManager使用ThreadLocal来为不同的事物线程提供独立的资源副本，并且同时维护这些事物的配置属性和运行状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程上下文中保存着[线程池对象：ConnectHolder]的Map对象。线程可以通过该属性获取到同一个Connection对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line"><span class="comment">// 事务同步器，自定义扩展方法，每个线程都可以注册N个事务同步器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transaction synchronizations"</span>);</span><br><span class="line"><span class="comment">// 事务的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction name"</span>);</span><br><span class="line"><span class="comment">// 事务是否只读</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction read-only status"</span>);</span><br><span class="line"><span class="comment">// 事务的隔离级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction isolation level"</span>);</span><br><span class="line"><span class="comment">// 事务是否开启</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Actual transaction active"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="事物信息绑定"><a href="#事物信息绑定" class="headerlink" title="事物信息绑定"></a>事物信息绑定</h2><p>在org.springframework.jdbc.datasource.DataSourceTransactionManager#doBegin中，DataSourceTransactionObject收判断是否为新建的，若是新增的，将对其进行绑定。TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bindResource</span><span class="params">(Object key, Object value)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">	Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">	Assert.notNull(value, <span class="string">"Value must not be null"</span>);</span><br><span class="line">	Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">	<span class="comment">// set ThreadLocal Map if none found</span></span><br><span class="line">	<span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">		map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		resources.set(map);</span><br><span class="line">	&#125;</span><br><span class="line">	Object oldValue = map.put(actualKey, value);</span><br><span class="line">	<span class="comment">// Transparently suppress a ResourceHolder that was marked as void...</span></span><br><span class="line">	<span class="keyword">if</span> (oldValue <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) oldValue).isVoid()) &#123;</span><br><span class="line">		oldValue = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (oldValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already value ["</span> + oldValue + <span class="string">"] for key ["</span> +</span><br><span class="line">				actualKey + <span class="string">"] bound to thread ["</span> + Thread.currentThread().getName() + <span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">"Bound value ["</span> + value + <span class="string">"] for key ["</span> + actualKey + <span class="string">"] to thread ["</span> +</span><br><span class="line">				Thread.currentThread().getName() + <span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化事物同步器"><a href="#初始化事物同步器" class="headerlink" title="初始化事物同步器"></a>初始化事物同步器</h2><p>在TransactionInterceptor中，执行invoke，对事物方法进行拦截处理。由父类org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction实际执行过程中，调用TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);创建TransactionInfo时，会调用AbstractPlatformTransactionManager#prepareSynchronization方法初始化事务同步器。</p>
<h3 id="创建TransactionInfo"><a href="#创建TransactionInfo" class="headerlink" title="创建TransactionInfo"></a>创建TransactionInfo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 获取TransactionStatus</span></span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +</span><br><span class="line">						<span class="string">"] because no transaction manager has been configured"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过制定的属性和状态创建TransactionInfo</span></span><br><span class="line">	<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过制定的属性和状态创建TransactionInfo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">prepareTransactionInfo</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable TransactionAttribute txAttr, String joinpointIdentification,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable TransactionStatus status)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	TransactionInfo txInfo = <span class="keyword">new</span> TransactionInfo(tm, txAttr, joinpointIdentification);</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// We need a transaction for this method...</span></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Getting transaction for ["</span> + txInfo.getJoinpointIdentification() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The transaction manager will flag an error if an incompatible tx already exists.</span></span><br><span class="line">		txInfo.newTransactionStatus(status);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// The TransactionInfo.hasTransaction() method will return false. We created it only</span></span><br><span class="line">		<span class="comment">// to preserve the integrity of the ThreadLocal stack maintained in this class.</span></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled())</span><br><span class="line">			logger.trace(<span class="string">"Don't need to create transaction for ["</span> + joinpointIdentification +</span><br><span class="line">					<span class="string">"]: This method isn't transactional."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We always bind the TransactionInfo to the thread, even if we didn't create</span></span><br><span class="line">	<span class="comment">// a new transaction here. This guarantees that the TransactionInfo stack</span></span><br><span class="line">	<span class="comment">// will be managed correctly even if no transaction was created by this aspect.</span></span><br><span class="line">	<span class="comment">// 绑定TransactionInfo </span></span><br><span class="line">	txInfo.bindToThread();</span><br><span class="line">	<span class="keyword">return</span> txInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化事物同步器-1"><a href="#初始化事物同步器-1" class="headerlink" title="初始化事物同步器"></a>初始化事物同步器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize transaction synchronization as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareSynchronization</span><span class="params">(DefaultTransactionStatus status, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">		TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(</span><br><span class="line">				definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?</span><br><span class="line">						definition.getIsolationLevel() : <span class="keyword">null</span>);</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());</span><br><span class="line">		TransactionSynchronizationManager.initSynchronization();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TransactionSynchronization"><a href="#TransactionSynchronization" class="headerlink" title="TransactionSynchronization"></a>TransactionSynchronization</h2><p><img src="/2020/08/13/2020081301/TransactionSynchronizationAdapter.png" alt="事物同步类结构"></p>
<p>事物同步的扩展点，用于事物同步回调的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationAdapter</span> <span class="keyword">implements</span> <span class="title">TransactionSynchronization</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 事务挂起</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//事务恢复</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将基础会话刷新到数据存储区（如果适用）</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在事务提交前触发，此处若发生异常，会导致回滚</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCommit</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在beforeCommit之后，commit/rollback之前执行。即使异常，也不会回滚</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事务提交后执行</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事务提交/回滚执行</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事件机制</title>
    <url>/2019/04/25/redisEvent1/</url>
    <content><![CDATA[<blockquote>
<p>Redis有两类事件：文件事件和时间事件，这两个事件组成了Redis的服务器的事件驱动程序。<a id="more"></a>  </p>
</blockquote>
<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis基于Reactor模式开发了自己的网络时间处理器：这个处理器被称为文件事件处理器。</p>
<p>文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的时间处理器。</p>
<p>当被监听的套接字准备好执行连结应答（accept）读取（read）写入（write）关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
<p><img src="/2019/04/25/redisEvent1/FileEvent.png" alt="&#39;文件事件处理器的四个组成部分&#39;"></p>
<p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字。</p>
<p>文件事件分派器接受I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。</p>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>Redis的时间事件分为以下两类：</p>
<p>定时事件：让一段程序在指定的时间之后执行一次。<br>周期事件：让一段程序每隔指定时间就执行一次。</p>
<p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p><img src="/2019/04/25/redisEvent1/Event.png" alt="事件处理角度下的服务器运行流程"></p>
<p>时间事件的运用实例：serverCron函数，它的主要工作包括：</p>
<ol>
<li>更新服务器的各类统计信息，比如：时间、内存占用、数据库占用情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭清理连接失效的客户端。</li>
<li>尝试进行AOF或RDB之久化操作。</li>
<li>如果服务器是主服务器，对从服务器进行定期同步。</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ol>
<p>文件事件和时间事件是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中不会进行抢占。</p>
]]></content>
      <tags>
        <tag>Redis Event</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据对象初识</title>
    <url>/2018/06/19/redisObjectInfo/</url>
    <content><![CDATA[<blockquote>
<p>&emsp;&emsp;首先带着这几个问题：</p>
</blockquote>
<ol>
<li><p>redis有哪些对象？</p>
</li>
<li><p>redis对象底层的数据结构是什么？</p>
</li>
<li><p>为什么要选择这种数据结构？ <a id="more"></a></p>
</li>
</ol>
<h5 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h5><p>&emsp;&emsp;Redis每创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键，一个用作键值对的值。每一个对象都由一个redisObject结构表示，结构中和保存数据有关的数据有三个属性分别是type属性、encoding属性和ptr属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">	// 类型</span><br><span class="line">	unsinged type:4;</span><br><span class="line">	// 编码</span><br><span class="line">	unsinged encoding:4;</span><br><span class="line">	// 指向底层实现数据结构的指针</span><br><span class="line">	void *ptr;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Redis的对象有字符串（String），列表（List），集合（Set），哈希（Hash），有序集合（ZSet）这几种对象。</p>
<ul>
<li>字符串对象 </li>
</ul>
<ol>
<li>字符串对象的编码可以是int、raw或者embStr。 </li>
<li>对于int编码的字符串对象来说，如果我们执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值，那么字符串对象的编码将从int变为raw。 </li>
<li>对embStr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embStr转换成raw，然后在执行命令。所以，embStr编码的字符串对象在执行修改命令之后，总会变成一个raw编码的字符串对象。 </li>
</ol>
<ul>
<li>列表对象 </li>
</ul>
<ol>
<li><p>列表对象的编码可以是ziplist或者linkedlist。 </p>
</li>
<li><p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存一个列表元素。 </p>
</li>
<li><p>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。 </p>
</li>
<li><p>编码转换 </p>
<p>&emsp;&emsp;当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：列表对象保存的所有字符串元素的长度都小于64字节；列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。 </p>
</li>
</ol>
<ul>
<li>哈希对象 </li>
</ul>
<ol>
<li><p>哈希对象的编码可以是ziplist或者hashtable。 </p>
</li>
<li><p>ziplist 编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，所以保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；先添加到哈希对象中的键值对会放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。 </p>
</li>
<li><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典值来保存：字典的每个键都是一个字符串对象，对象中保存了键值对的键。字典中的每一个值都是一个字符串对象，对象中保存了键值对的值。 </p>
</li>
<li><p>编码转换 </p>
<p>&emsp;&emsp;当哈希对象可以同时满足以下两个条件时，列表对象使用ziplist编码：哈希对象保存的所有字符串元素的长度都小于64字节；哈希对象保存的元素数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。 </p>
</li>
</ol>
<ul>
<li>集合对象 </li>
</ul>
<ol>
<li><p>集合对象的编码可以是inset或者hashtable。 </p>
</li>
<li><p>inset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面 </p>
</li>
<li><p>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，字典的值则全部被设置为null。 </p>
</li>
<li><p>编码的转换 </p>
<p>&emsp;&emsp;当集合对象可以同时满足以下两个条件时，对象使用insert编码：集合对象保存的所有元素都是整数值,集合对象保存的元素数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。 </p>
</li>
</ol>
<ul>
<li><p>有序集合对象 </p>
<p>&emsp;&emsp;有序集合的编码可以是ziplist或者skiplist。 </p>
<ol>
<li><p>ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的位置，而分值较大的元素则被放置在靠近表尾的位置。 </p>
</li>
<li><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表。zset结构中的zs1跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。 </p>
</li>
<li><p>编码转换 </p>
<p>&emsp;&emsp;当有序集合对象可以同时满足以下两个条件时，对象可以使用ziplist编码：有序集合对象保存的元素数量小于128个；有序集合对象保存的所有元素成员的长度都小于64字节；不能满足这两个条件的列表对象需要使用skiplist编码。 </p>
<p><img src="/2018/06/19/redisObjectInfo/redis对象.png" alt="&#39;Redis对象&#39;"></p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis Object</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/2018/11/25/redisback/</url>
    <content><![CDATA[<blockquote>
<p>Redis的持久话方式分为AOF(Append Of File)和RDB两种方式。<a id="more"></a> </p>
</blockquote>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><h4 id="RDB文件的创建与加载"><a href="#RDB文件的创建与加载" class="headerlink" title="RDB文件的创建与加载"></a>RDB文件的创建与加载</h4><p>&emsp;&emsp;有两个Redis命令可用于生成RDB文件，一个SAVE，另一个事BGSAVE。</p>
<p>&emsp;&emsp;SAVE命令会<font color="red">阻塞</font>Redis服务器进程。直到RDB文件创建完成为止，<font color="red">在服务器进程阻塞期间，服务器不能处理任何命令请求</font>。</p>
<p>&emsp;&emsp;BGSAVE命令会派生一个<font color="red">子进程</font>，然后由子进程负责创建RDB文件，<font color="red">服务器进行（父进程）继续处理命令请求</font>。</p>
<p>&emsp;&emsp;RDB文件的载入工作是在服务器启动时自动执行的，所以无论是SAVE、BGSAVE生成的RDB文件，载入的方式都是一致的。<font color="red">只要RDB服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</font></p>
<p>&emsp;&emsp;因为AOF文件的更新频率通常比RDB文件的更新的频率高，所以:</p>
<ol>
<li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li>
<li>只有在AOF持久化功能处于关闭状态时，服务器才使用RDB文件来还原数据库状态。</li>
</ol>
<p>&emsp;&emsp;服务器禁止SAVE命令和BGSAVE命令同时执行是为了父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止发生竞争。其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE也会产生竞争条件。</p>
<p>&emsp;&emsp;因为BGSAVE命令可以不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每个一段时间自动执行一次BGSAVE命令。</p>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF持久化的功能可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<h4 id="AOF文件的创建"><a href="#AOF文件的创建" class="headerlink" title="AOF文件的创建"></a>AOF文件的创建</h4><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>&emsp;&emsp;当AOF持久化功能处于打开状态时，服务器在执行完一个写入命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof buf缓冲区的末尾。</p>
<h5 id="AOF的文件写入"><a href="#AOF的文件写入" class="headerlink" title="AOF的文件写入"></a>AOF的文件写入</h5><p>&emsp;&emsp;Redis的服务器进程就是一个事件循环。因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到aof文件里面。</p>
<h5 id="AOF的文件同步"><a href="#AOF的文件同步" class="headerlink" title="AOF的文件同步"></a>AOF的文件同步</h5><p>&emsp;&emsp;为了提高文件的写入效率，在现代操作系统中，当用户调用writer函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满，或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p>
<p>&emsp;&emsp;为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p>
<h4 id="AOF文件载入与数据还原"><a href="#AOF文件载入与数据还原" class="headerlink" title="AOF文件载入与数据还原"></a>AOF文件载入与数据还原</h4><p><img src="/2018/11/25/redisback/repository.png" alt="文件载入过程"></p>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>&emsp;&emsp;为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比AOF文件的体积要小的多。</p>
<p>&emsp;&emsp;虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF重写并不需要对现有的AOF文件进行任何读取、分析、或着写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p>
<p>&emsp;&emsp;首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现。（<font color="red">先读后写</font>）</p>
<p><img src="/2018/11/25/redisback/aof01.png" alt="服务器同时将命令发送给AOF文件和AOF重写缓冲区"></p>
<p>&emsp;&emsp;Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，可以同时达到两个目的：</p>
<ol>
<li>子进程进行AOF重写期间，服务器进行（父进程）可以处理命令请求。</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li>
</ol>
<h5 id="AOF重写过程中数据不一致的问题解决"><a href="#AOF重写过程中数据不一致的问题解决" class="headerlink" title="AOF重写过程中数据不一致的问题解决"></a>AOF重写过程中数据不一致的问题解决</h5><p>&emsp;&emsp;为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行了一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p>
<p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p>
<ol>
<li>将AOF重写缓冲区中的所有内容写入到新AOF文件汇总，这是新AOF文件所保存的数据库将和服务器当前的数据库状态一致。</li>
<li>对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li>
</ol>
<p>&emsp;&emsp;在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，其余时间，AOF后台重写都不会阻塞父进程。</p>
]]></content>
      <tags>
        <tag>RDB</tag>
        <tag>AOF</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ事务消息知悉</title>
    <url>/2018/12/01/rocketmq2/</url>
    <content><![CDATA[<blockquote>
<p>RocketMQ的事务消息用途广泛，也是很多人消息中间件选择RocketMQ的一个重要原因。<a id="more"></a></p>
</blockquote>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ的事务消息队列提供类似X/Open XA的分布式事务功能，通过消息队列RocketMQ事务消息能达到分布式事务的最终一致。</p>
<p>半消息：暂不能投敌的消息，发送方已经将消息成功地发送到了消息队列RocketMQ服务段，但是服务端未收到生产着对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即为半消息，</p>
<p>消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，消息队列RocketMQ服务端通过扫描发现某条消息长期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit或是Rollback），此过程即为消息回查。</p>
<p><img src="/2018/12/01/rocketmq2/rocketmq2.png" alt="RocketMQ事务流程"></p>
<ol>
<li>发送方向消息队列RocketMQ服务端发送消息。</li>
<li><p>服务端将消息持久化成功后，向发送方ACK确认消息已经发送成功，此时消息为半消息。</p>
</li>
<li><p>发送方开始执行本地事务逻辑。</p>
</li>
<li>发送方根据本地事务执行结果向服务端提交二次确认（commit或是rollback），服务端收到commit状态</li>
</ol>
<p>则将半消息标记为可投递状态，订阅方最终将收到该消息；服务端收到rollback状态，则删除半消息，订阅方将不会收到该消息。</p>
<ol start="5">
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认没有抵达RocketMQ的服务端，经过固定时间后，服务端将会对消息进行回查。</li>
<li><p>发送方收到消息回查结果后，需要检查对应消息的本地事务执行的最终结果。</p>
</li>
<li><p>发送方根据检查到的本地事务的最终状态再此提交二次确认，服务端仍按照步骤四对半消息进行操作。</p>
</li>
</ol>
<p>在实际操作中需要注意的是事务消息的Group ID不能与其他类型消息的Group ID共用。与其他消息不同的是，事务消息有回查机制，回查时消息队列RocketMQ服务端会根据Group ID去查询客户端。如果是通过 ONSFactory.createTransactionProducer 创建事务消息的 Producer 时必须指定 LocalTransactionChecker 的实现类，处理异常情况下事务消息的回查。</p>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>消息事务</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot是如何进行自动配置的？</title>
    <url>/2019/06/04/springboot01/</url>
    <content><![CDATA[<blockquote>
<p>平时一直在使用SpringBoot，但是没有进入深入的了解，公司需要对原有的项目改造升级，借着这个机会了解下SpringBoot的自动加载机制。<a id="more"></a></p>
</blockquote>
<p>&emsp;&emsp;因为公司向对dubbo进行升级，解决dubbo优雅停机等bug问题，借着这个机会，升级改造项目使用SpringBoot。</p>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Value</td>
<td>@Value 就相当于传统 xml 配置文件中的 value 字段。</td>
</tr>
<tr>
<td>@ConfigurationProperties</td>
<td>对标记有@ConfigurationProperties的类所有属性和配置文件中相关的配置项进行绑定。（默认从全局配置文件中获取配置值），绑定之后我们就可以通过这个类去访问全局配置文件中的属性值了。</td>
</tr>
<tr>
<td>@Import</td>
<td>@Import注解支持导入普通Java类，并将其声明成一个bean。主要用于将对各分散的java config配置类融合成一个更大的config类。</td>
</tr>
<tr>
<td>@Conditional</td>
<td>@Conditional注释可以实现只有在特定条件满足时才启用一些配置。</td>
</tr>
</tbody>
</table>
<h4 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h4><p>&emsp;&emsp;SpringBoot的自动配置源头一切都要从@SpringBootApplication这个注解开始说起。</p>
<p>@SpringBootApplication 标注在某个类上说明：</p>
<ul>
<li>这个类是 SpringBoot 的主配置类。</li>
<li>SpringBoot 就应该运行这个类的 main 方法来启动 SpringBoot 应用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过源码可知，@SpringBootApplication是一个组合注解，由三个注解组成：</p>
<p>@SpringBootConfiguration：该注解表示这是一个SpringBoot的配置类，其实就是一个Configuration注解而已。</p>
<p>@EnableAutoConfiguration：开启自动配置。</p>
<p>@ComponentScan：开启组件扫描。</p>
<p>在查看下开启自动配置的的注解类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">	 * applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@EnableAutoConfiguration注解由@AutoConfigurationPackage和@Import两个注解组成。</p>
<p>@AutoConfigurationPackage：由@Import(AutoConfigurationPackages.Registrar.class)可知，其注解主要是将主配置类（@SpringBootConfiguration标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器中。</p>
<p>@Import自动导入了AutoConfigurationImportSelector.class配置类。</p>
<p>&emsp;&emsp;通过AutoConfigurationImportSelector#selectImports方法返回需要导入的组件的全类名数组的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">		&#125;</span><br><span class="line">  <span class="comment">//1、加载META-INF/spring-autoconfigure-metadata.properties文件</span></span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">				.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">				annotationMetadata);</span><br><span class="line">  <span class="comment">//3. 将EnableAutoConfiguration的值封装在一个数组中返回。</span></span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>通过 getAutoConfigurationEntry() -&gt; getCandidateConfigurations() -&gt; loadFactoryNames()查找全类名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">				getBeanClassLoader());</span><br><span class="line">		Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">				+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在loadFactoryNames方法中，从当前项目的路径中获取所有MATA-INF/spring.factories文件中的信息。将获取到的信息封装为一个Map返回。在从map中通过传入的 EnableAutoConfiguration.class参数，获取该key下的所有值。</p>
<p>对获取的AutoConfigurationEntry进行过滤，过滤的依据是条件匹配。通过org.springframework.boot.autoconfigure.AutoConfigurationImportFilter过滤器进行过滤，分为configurations，exclusions两个集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">		&#125;</span><br><span class="line">		AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">		configurations = removeDuplicates(configurations);</span><br><span class="line">		Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">		checkExcludedClasses(configurations, exclusions);</span><br><span class="line">		configurations.removeAll(exclusions);</span><br><span class="line">		configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">		fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;SpringBoot的自动配置体现了约定大于配置的设计理念。将SpringBoot需要的jar在Spring.factories中配置。通过SPI的设计模式，在服务启动时，用ServiceLoader进行加载。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot 自动配置</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务学习</title>
    <url>/2019/04/29/tcc01/</url>
    <content><![CDATA[<blockquote>
<p> 事务在分布式服务中至关重要，本文主要学习TCC三阶段的流程与模式。了解XA模式。<a id="more"></a></p>
</blockquote>
<h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><p>数据库事务是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
<p>事务有ACID四个特性：</p>
<ol>
<li>原子性：事务作为一个整体被执行，包括在其中的对数据的操作要么全部执行要么全部被执行，要么都不执行。</li>
<li>一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应该满足完整性约束。</li>
<li>隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。</li>
<li>持久性：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作不可逆转。</li>
</ol>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h4><p>XA协议由Tuxedo首先提出，并交给X/Open组织，作为资源管理器（数据库）与事务管理器的接口标准。XA协议采用两阶段提交的方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准交口。</p>
<p>资源管理器（RM）：资源管理器提供对事务性资源的访问。数据库其实就是一种资源管理器，必须提交或者回滚由RM管理的事务。</p>
<p>事务管理器（TM）：主要协调作为全局事务中的部分事务。它作为RMS中每个事务的协调者。</p>
<p>执行全局事务的过程采用两阶段提交（2PC），全局事务是发生在分支执行的操作之后的：</p>
<p>第一阶段：所有分支的操作都准备好了，由TM告知每个分支准备提交，此时，作为全局事务中的每个RM记录着在稳定存储中的动作。</p>
<p>第二阶段：TM会告诉RMS是否提交或回滚，如果所有分支表明准备好能够提交时，RMS会被告知提交，如果任何一个RM表明没有准备好或者不能提交，则进行全部回滚。</p>
<p><img src="/2019/04/29/tcc01/xa.png" alt="两阶段更新"></p>
<h4 id="TCC提交"><a href="#TCC提交" class="headerlink" title="TCC提交"></a>TCC提交</h4><p>TCC(Try-Confirm-Cancel)分布式事务模型相对于XA等传统模型，其特征在于它不依赖资源管理器（RM）对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。</p>
<p>初步操作Try：完成所有业务检查，预留必须的业务资源。</p>
<p>确认操作Confirm：真正执行的业务逻辑，不在任务业务检查，只使用Try阶段预留的业务资源。因此，只要Try操作成功，Confirm必须能成功。另外，Confirm操作需满足幂等性，保证一笔分布式事务又且只能成功一次。</p>
<p>取消操作Cancel：释放Try阶段预留的业务资源。同样的，Cancel操作也需要满足幂等性。</p>
<p><img src="/2019/04/29/tcc01/tcc.png" alt="三阶段提交模型（转自网上）"></p>
<p>TCC分布式事务模型包括三部分：</p>
<ol>
<li>主业务服务：主业务服务为整个业务活动的发起方，服务的编排者，负责发起并完成整个业务活动。</li>
<li>从业务服务：从业务服务是整个业务活动的参与方，负责提供TCC业务操作，实现初步操作（Try），确认操作（Confirm）、取消操作（Cancel）三个借口，供主业务服务调用。</li>
<li>业务活动管理器：业务活动管理器管理控制整个业务活动，包括记录维护TCC全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的Confirm操作，在业务活动取消调用所有从业务服务的Cancel操作。</li>
</ol>
<p>TCC分布式事务流程：</p>
<ol>
<li>主业务服务首先开启本地事务。</li>
<li>主业务服务向业务活动管理器申请启动分布式事务业务活动。</li>
<li>然后针对要调用的从业务服务，主业务活动先向业务活动管理器注册业务活动，然后调用从业务服务的Try接口；</li>
<li>当所有从业务服务的Try接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务。</li>
<li>若主业务服务提交本地事务，则TCC模型分别调用所有从业务服务的Confirm接口；若主业务服务回滚本地事务，则分别调用Cancel接口；</li>
<li>所有从业务服务的Confirm或Cancel操作完成后，全局事务结束。</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>写了一个例子用来学习TCC，地址：<a href="https://github.com/yosamaru/tccDemo" target="_blank" rel="noopener">https://github.com/yosamaru/tccDemo</a></p>
]]></content>
      <tags>
        <tag>TCC</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池参数分析</title>
    <url>/2019/03/06/threadpool1/</url>
    <content><![CDATA[<blockquote>
<p>一直在使用线程池创建线程，但是线程池的参数有什么用呢？<a id="more"></a></p>
</blockquote>
<h4 id="参数概念"><a href="#参数概念" class="headerlink" title="参数概念"></a>参数概念</h4><ol>
<li>corePoolSize：线程池中一直存活者的线程的最小数量。</li>
<li>maximumPoolSize：线程池内能够容纳线程数量的最大值，但是如果提供的阻塞队列（也就是参数workQueue）是一个无界队列，那么提供的maximumPoolSize的数值将毫无意义。</li>
<li>keepAliveTime：空闲线程处于等待状态的超时时间。如果执行的任务相对较多，并且每个任务执行的时间比较短，那么可以为该参数设置一个相对较大的数值，以提高线程的利用率。如果执行的任务相对较少，线程池使用率相对较低，那么可以先将参数设置为一个较小的数值，通过超时停止的机制来降低系统线程资源的开销，后续如果发现线程池的使用率逐渐增高以后，线程池会根据当前调教的任务数自动创建新的线程，当然，也可以手动调用setKeepAliveTime（long， TimeUnit)方法来重新设定keepAliveTime字段的值。</li>
<li>workQueue：workQueue是一个内部元素为Runable(各种任务，通常是异步任务)的阻塞队列。阻塞队列是一种类似于“生产者-消费者”模型的队列。当队列已满时如果继续向队列中插入元素，该插入操作将被阻塞一直处于等待状态，知道队列中有元素被移除产生空位子后，才有可能执行这次插入操作；当队列为空时，如果继续执行元素的删除或获取操作，该操作同样会被阻塞而进入等待状态，直到队列中又有了该元素后，才能执行该操作。</li>
</ol>
<h4 id="线程池操作"><a href="#线程池操作" class="headerlink" title="线程池操作"></a>线程池操作</h4><ol>
<li>如果线程池中正在运行的线程数少于核心线程数，那么线程池总是倾向于创建一个新线程来执行该任务，而不是将该任务提交到该队列workQueue中进行等待。</li>
<li>如果线程池中正在运行的线程数不少于核心线程数，那么线程池总是倾向于将该任务提交到队列workQueue中先让其等待，而不是创建一个新线程来执行该任务。</li>
<li>如果线程池中正在运行的线程数不少于核心线程数，并且线程池中的阻塞队列也满了使得该任务入队失败，那么线程池会去判断当前池子中运行的线程数是否已经等于了该线程池允许运行的最大线程数maximumPoolSize，如果发现已经等于了，说明线程池已满，无法在继续创建新的线程了，那么就会拒绝执行该任务。如果发现运行的线程数小于池子允许的最大线程数，那么就会创建一个线程（创建的线程是非核心线程）来执行该任务。</li>
</ol>
]]></content>
      <categories>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>线程池参数</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次服务启动时失败的问题</title>
    <url>/2019/06/03/work01/</url>
    <content><![CDATA[<blockquote>
<p>记录一次线上account服务第一次启动时，有效访问阻塞，启动失败的问题。<a id="more"></a></p>
</blockquote>
<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>&emsp;&emsp;在今天修改了account服务之后，发布到生产之后，发现携程的查询请求全部报错，阻塞在了account服务中。我们就对问题进行了排查。首先，预估有这个原因：</p>
<ol>
<li><p>Redis挂了，线程池没有起到作用。</p>
</li>
<li><p>在重新发布时，供应商信息没有存放在缓存中。</p>
</li>
</ol>
<h4 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h4><p>&emsp;&emsp;检查代码，发现代码没有问题，查看redis的线程池设计。我们用的redis线程池是用的commons-pool。查看获取对象的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T borrowObject() throws Exception &#123;</span><br><span class="line">        long starttime = System.currentTimeMillis();</span><br><span class="line">        GenericObjectPool.Latch&lt;T&gt; latch = new GenericObjectPool.Latch();</span><br><span class="line">        byte whenExhaustedAction;</span><br><span class="line">        long maxWait;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            whenExhaustedAction = this._whenExhaustedAction;</span><br><span class="line">            maxWait = this._maxWait;</span><br><span class="line">            this._allocationQueue.add(latch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.allocate();</span><br><span class="line"></span><br><span class="line">        while(true) &#123;</span><br><span class="line">        // 添加同步锁</span><br><span class="line">            synchronized(this) &#123;</span><br><span class="line">                this.assertOpen();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (latch.getPair() == null &amp;&amp; !latch.mayCreate()) &#123;</span><br><span class="line">                switch(whenExhaustedAction) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                		// 同步锁</span><br><span class="line">                    synchronized(this) &#123;</span><br><span class="line">                        if (latch.getPair() == null &amp;&amp; !latch.mayCreate()) &#123;</span><br><span class="line">                            this._allocationQueue.remove(latch);</span><br><span class="line">                            throw new NoSuchElementException(&quot;Pool exhausted&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                case 1:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        synchronized(latch) &#123;</span><br><span class="line">                            if (latch.getPair() != null || latch.mayCreate()) &#123;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            // 等待时间</span><br><span class="line">                            if (maxWait &lt;= 0L) &#123;</span><br><span class="line">                                latch.wait();</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                long elapsed = System.currentTimeMillis() - starttime;</span><br><span class="line">                                long waitTime = maxWait - elapsed;</span><br><span class="line">                                if (waitTime &gt; 0L) &#123;</span><br><span class="line">                                    latch.wait(waitTime);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (this.isClosed()) &#123;</span><br><span class="line">                            throw new IllegalStateException(&quot;Pool closed&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException var51) &#123;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而我们的问题就出现在了这个等待时间的问题上。</p>
<p>&emsp;&emsp;当account服务重新启动时，redis会从线程池中获取redis连接。而在第一次启动时，<font color="red">redisPool定义的最大资源数、最小空闲资源数时，不会真的把Jedis连接放到连接池里。第一次使用时，没有资源使用，会先创建一个新的链接，然后放到池子里，会有一定的时间开销。</font>而在这一段时间里，携程等OTA的搜索量非常大，要在account服务查询大量的供应商信息，造成堵塞。所以在account服务启动前3分钟时，会造成携程的搜索失败率很高，有时直接account服务启动失败。所以我们考虑<font color="red">要在account服务启动时，先要为redisPool进行预热。</font></p>
<p>&emsp;&emsp;携程的机票搜索一直调用account服务，但是只是在account服务查询供应商的信息，而这些供应商信息一般都是固定的。所以最后我们决定使用本地缓存。在每一个对外查询接口进行添加本地缓存，同时，为了防止突然修改供应商信息，需要刷新本地缓存，我们修改供应商信息时会通知给zookeeper，一但本地缓存的程序发现供应商信息修改了，会自动刷新本地缓存。</p>
]]></content>
      <categories>
        <category>生产故障</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
</search>
